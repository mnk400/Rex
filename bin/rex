#!/bin/bash
# rex — A dynamic CLI tool that auto-discovers scripts from configured directories
#
# Scripts are organized into topics (subdirectories) and standalone commands.
# Rex reads metadata from script headers for descriptions and ignore rules.
#
# Script metadata comments:
#   # Description: <text>              - Script description
#   # @raycast.description <text>      - Also accepted for description
#   # rex.ignore                       - Exclude script from discovery
#   # Runbook.ignore                   - Also accepted (backwards compat)

set -euo pipefail

REX_VERSION="0.dev.build"

# BSD find (macOS) uses -perm +111, GNU find (Linux) uses -perm $_PERM_EXEC
if [[ "$(uname)" == "Darwin" ]]; then
    _PERM_EXEC="+111"
else
    _PERM_EXEC="/111"
fi
REX_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/rex"
REX_CONFIG_FILE="$REX_CONFIG_DIR/config"

# ── Config ────────────────────────────────────────────────────────────────────

ensure_config() {
    if [[ ! -d "$REX_CONFIG_DIR" ]]; then
        mkdir -p "$REX_CONFIG_DIR"
    fi
    if [[ ! -f "$REX_CONFIG_FILE" ]]; then
        cat > "$REX_CONFIG_FILE" << 'EOF'
# Rex script directories (one path per line)
# Add directories with: rex dirs add <path>
EOF
    fi
}

# Read configured directories, skip comments and blank lines
get_directories() {
    ensure_config
    while IFS= read -r line; do
        line="${line%%#*}"           # strip inline comments
        line="${line#"${line%%[![:space:]]*}"}"  # trim leading whitespace
        line="${line%"${line##*[![:space:]]}"}"  # trim trailing whitespace
        [[ -n "$line" ]] && [[ -d "$line" ]] && echo "$line"
    done < "$REX_CONFIG_FILE"
    return 0
}

# ── Metadata ──────────────────────────────────────────────────────────────────

get_script_description() {
    local script="$1"
    local description=""
    if [[ -f "$script" ]]; then
        description=$(grep -m1 "^#.*@raycast\.description\|^#.*Description:" "$script" 2>/dev/null \
            | sed 's/^#[[:space:]]*@raycast\.description[[:space:]]*//' \
            | sed 's/^#[[:space:]]*Description:[[:space:]]*//')
    fi
    echo "${description:-No description available}"
}

is_script_ignored() {
    local script="$1"
    [[ -f "$script" ]] && grep -qm1 "^#.*rex\.ignore\|^#.*Runbook\.ignore" "$script" 2>/dev/null
}

# ── Discovery ─────────────────────────────────────────────────────────────────

# Discover all topics across all configured directories
# Output: topic_name|directory_path
discover_topics() {
    local seen_topics=()
    while IFS= read -r dir; do
        find "$dir" -maxdepth 1 -type d ! -name ".*" ! -path "$dir" 2>/dev/null | sort | while read -r topic_dir; do
            local topic
            topic=$(basename "$topic_dir")
            # Only include if it has executable files
            if find "$topic_dir" -maxdepth 1 -type f -perm $_PERM_EXEC 2>/dev/null | grep -q .; then
                echo "$topic|$dir"
            fi
        done
    done < <(get_directories)
}

# Get unique topic names
discover_topic_names() {
    discover_topics | cut -d'|' -f1 | sort -u
}

# Discover commands for a topic across all directories
# Output: command_name|script_path|source_dir
discover_commands() {
    local topic="$1"
    local seen_commands=()

    while IFS= read -r dir; do
        local topic_dir="$dir/$topic"
        [[ -d "$topic_dir" ]] || continue

        find "$topic_dir" -maxdepth 1 -type f -perm $_PERM_EXEC 2>/dev/null | sort | while read -r script; do
            is_script_ignored "$script" && continue
            local bn
            bn=$(basename "$script")
            local command_name="${bn%.*}"
            # Strip topic prefix (e.g., nas-sync -> sync)
            command_name="${command_name#"$topic"-}"
            echo "$command_name|$script|$dir"
        done
    done < <(get_directories)
}

# Discover standalone scripts across all directories
# Output: command_name|script_path|source_dir
discover_standalone() {
    while IFS= read -r dir; do
        find "$dir" -maxdepth 1 -type f -perm $_PERM_EXEC ! -name "rex*" ! -name "runbook*" 2>/dev/null | sort | while read -r script; do
            is_script_ignored "$script" && continue
            local bn
            bn=$(basename "$script")
            local command_name="${bn%.*}"
            echo "$command_name|$script|$dir"
        done
    done < <(get_directories)
}

# Resolve the first matching command from pipe-delimited discovery output
# Output: script_path
_resolve_first_match() {
    local command="$1"
    while IFS='|' read -r cmd script_path source_dir; do
        if [[ "$cmd" == "$command" ]]; then
            echo "$script_path"
            return 0
        fi
    done
}

resolve_command() {
    _resolve_first_match "$2" < <(discover_commands "$1")
}

resolve_standalone() {
    _resolve_first_match "$1" < <(discover_standalone)
}

# ── Helpers ───────────────────────────────────────────────────────────────────

# String-based dedup (bash 3.x compatible). Usage:
#   local _seen="|"
#   _is_seen "$name" && continue; _seen="$_seen$name|"
_is_seen() {
    case "$_seen" in
        *"|$1|"*) return 0 ;;
        *) return 1 ;;
    esac
}

# ── Display ───────────────────────────────────────────────────────────────────

show_help() {
    echo "rex v${REX_VERSION} — script runner"
    echo ""
    echo "Usage: rex <topic> <command> [args...]"
    echo "       rex <command> [args...]"
    echo ""

    local dirs
    dirs=$(get_directories)
    if [[ -z "$dirs" ]]; then
        echo "No directories configured. Add one with:"
        echo "  rex dirs add <path>"
        return
    fi

    local topics
    topics=$(discover_topic_names)
    if [[ -n "$topics" ]]; then
        echo "Topics:"
        while read -r topic; do
            local cmd_count
            cmd_count=$(discover_commands "$topic" | wc -l | tr -d ' ')
            printf "  %-16s %s commands\n" "$topic" "$cmd_count"
        done <<< "$topics"
        echo ""
    fi

    local standalone_count
    standalone_count=$(discover_standalone | wc -l | tr -d ' ')
    if [[ "$standalone_count" -gt 0 ]]; then
        echo "Standalone commands: $standalone_count available"
        echo ""
    fi

    echo "Commands:"
    echo "  rex <topic> list       Show commands for a topic"
    echo "  rex list               List all available commands"
    echo "  rex new <cmd>          Scaffold a new script"
    echo "  rex edit <cmd>         Open a script in \$EDITOR"
    echo "  rex dirs               Show configured directories"
    echo "  rex dirs add <path>    Add a script directory"
    echo "  rex dirs remove <path> Remove a script directory"
    echo "  rex version            Show version"
}

show_topic_help() {
    local topic="$1"
    echo "Usage: rex $topic <command> [args...]"
    echo ""
    echo "Available commands:"

    local _seen="|"
    while IFS='|' read -r command script_path source_dir; do
        _is_seen "$command" && continue; _seen="$_seen$command|"

        local description
        description=$(get_script_description "$script_path")
        printf "  %-24s %s\n" "$command" "$description"
    done < <(discover_commands "$topic")
}

_print_command_list() {
    local dir_count="$1"
    local _seen="|"
    while IFS='|' read -r command script_path source_dir; do
        _is_seen "$command" && continue; _seen="$_seen$command|"

        local description
        description=$(get_script_description "$script_path")
        local dir_label=""
        if [[ "$dir_count" -gt 1 ]]; then
            dir_label=" ($(basename "$source_dir"))"
        fi
        printf "  %-24s %s%s\n" "$command" "$description" "$dir_label"
    done
}

list_all_commands() {
    local dirs
    dirs=$(get_directories)
    if [[ -z "$dirs" ]]; then
        echo "No directories configured. Add one with:"
        echo "  rex dirs add <path>"
        return
    fi

    echo "All available commands:"
    echo ""

    local dir_count
    dir_count=$(get_directories | wc -l | tr -d ' ')

    discover_topic_names | while read -r topic; do
        echo "[$topic]"
        _print_command_list "$dir_count" < <(discover_commands "$topic")
        echo ""
    done

    # Standalone commands
    local standalone
    standalone=$(discover_standalone)
    if [[ -n "$standalone" ]]; then
        echo "[standalone]"
        _print_command_list "$dir_count" <<< "$standalone"
    fi
}

# ── Directory Management ─────────────────────────────────────────────────────

cmd_dirs() {
    local subcmd="${1:-}"

    case "$subcmd" in
        "add")
            local path="${2:-}"
            if [[ -z "$path" ]]; then
                echo "Usage: rex dirs add <path>"
                exit 1
            fi

            # Resolve to absolute path
            local abs_path
            abs_path=$(cd "$path" 2>/dev/null && pwd || true)
            if [[ -z "$abs_path" ]]; then
                echo "Error: directory does not exist: $path"
                exit 1
            fi

            # Check if already configured
            while IFS= read -r existing; do
                if [[ "$existing" == "$abs_path" ]]; then
                    echo "Already configured: $abs_path"
                    return
                fi
            done < <(get_directories)

            ensure_config
            echo "$abs_path" >> "$REX_CONFIG_FILE"
            echo "Added: $abs_path"
            ;;

        "remove")
            local path="${2:-}"
            if [[ -z "$path" ]]; then
                echo "Usage: rex dirs remove <path>"
                exit 1
            fi

            # Resolve to absolute path (may not exist anymore)
            local abs_path
            if [[ -d "$path" ]]; then
                abs_path=$(cd "$path" && pwd)
            else
                abs_path="$path"
            fi

            ensure_config
            local tmp
            tmp=$(mktemp)
            local found=false
            while IFS= read -r line; do
                local clean="${line%%#*}"
                clean="${clean#"${clean%%[![:space:]]*}"}"
                clean="${clean%"${clean##*[![:space:]]}"}"
                if [[ "$clean" == "$abs_path" ]]; then
                    found=true
                else
                    echo "$line" >> "$tmp"
                fi
            done < "$REX_CONFIG_FILE"

            if $found; then
                mv "$tmp" "$REX_CONFIG_FILE"
                echo "Removed: $abs_path"
            else
                rm "$tmp"
                echo "Not found in config: $abs_path"
                exit 1
            fi
            ;;

        "")
            # List configured directories
            local dirs
            dirs=$(get_directories)
            if [[ -z "$dirs" ]]; then
                echo "No directories configured."
                echo ""
                echo "Add one with: rex dirs add <path>"
            else
                echo "Configured directories:"
                while IFS= read -r dir; do
                    local topic_count cmd_count
                    topic_count=$(find "$dir" -maxdepth 1 -type d ! -name ".*" ! -path "$dir" 2>/dev/null | wc -l | tr -d ' ')
                    echo "  $dir ($topic_count topics)"
                done <<< "$dirs"
            fi
            ;;

        *)
            echo "Unknown dirs command: $subcmd"
            echo "Usage: rex dirs [add|remove] [path]"
            exit 1
            ;;
    esac
}

# ── Completions ───────────────────────────────────────────────────────────────

# Output completion words for the current cursor position
# Usage: rex --cmplt <cword_index> <words...>
_rex_completions() {
    local cword="$1"
    shift
    local words=("$@")

    case "$cword" in
        1)
            # Complete first argument: built-ins + topics + standalone
            echo "help"
            echo "version"
            echo "list"
            echo "dirs"
            echo "new"
            echo "edit"
            echo "completions"
            discover_topic_names 2>/dev/null
            discover_standalone 2>/dev/null | cut -d'|' -f1
            ;;
        2)
            local prev="${words[1]:-}"
            case "$prev" in
                dirs)
                    echo "add"
                    echo "remove"
                    echo "list"
                    ;;
                completions)
                    echo "bash"
                    echo "zsh"
                    ;;
                *)
                    # If prev is a topic, complete with its commands
                    local is_topic=false
                    while IFS='|' read -r topic_name topic_dir; do
                        if [[ "$topic_name" == "$prev" ]]; then
                            is_topic=true
                            break
                        fi
                    done < <(discover_topics 2>/dev/null)

                    if $is_topic; then
                        echo "help"
                        echo "list"
                        local _seen="|"
                        while IFS='|' read -r cmd script_path source_dir; do
                            _is_seen "$cmd" && continue; _seen="$_seen$cmd|"
                            echo "$cmd"
                        done < <(discover_commands "$prev" 2>/dev/null)
                    fi
                    ;;
            esac
            ;;
    esac
}

cmd_completions() {
    local shell="${1:-}"
    case "$shell" in
        bash)
            cat << 'BASH_COMPLETION'
_rex_bash_completions() {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local completions
    completions=$(rex --cmplt "$COMP_CWORD" "${COMP_WORDS[@]}" 2>/dev/null)
    COMPREPLY=($(compgen -W "$completions" -- "$cur"))
}
complete -F _rex_bash_completions rex
BASH_COMPLETION
            ;;
        zsh)
            cat << 'ZSH_COMPLETION'
_rex_zsh_completions() {
    local completions
    completions=("${(@f)$(rex --cmplt "$((CURRENT - 1))" "${words[@]}" 2>/dev/null)}")
    compadd -a completions
}
compdef _rex_zsh_completions rex
ZSH_COMPLETION
            ;;
        *)
            echo "Usage: rex completions [bash|zsh]"
            echo ""
            echo "Add to your shell profile:"
            echo "  bash: eval \"\$(rex completions bash)\""
            echo "  zsh:  eval \"\$(rex completions zsh)\""
            ;;
    esac
}

# ── New ───────────────────────────────────────────────────────────────────────

cmd_new() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        echo "Usage: rex new <command>"
        echo "       rex new <topic> <command>"
        exit 1
    fi

    ensure_config

    # Collect directories into an array
    local dirs=()
    while IFS= read -r d; do
        dirs+=("$d")
    done < <(get_directories)

    if [[ ${#dirs[@]} -eq 0 ]]; then
        echo "No directories configured. Add one with:"
        echo "  rex dirs add <path>"
        exit 1
    fi

    # Pick target directory
    local target_dir
    if [[ ${#dirs[@]} -eq 1 ]]; then
        target_dir="${dirs[0]}"
    else
        echo "Select a directory:"
        local i
        for i in "${!dirs[@]}"; do
            echo "  $((i + 1))) ${dirs[$i]}"
        done
        local choice
        read -p "Directory [1-${#dirs[@]}]: " choice
        if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 ]] || [[ "$choice" -gt ${#dirs[@]} ]]; then
            echo "Invalid selection"
            exit 1
        fi
        target_dir="${dirs[$((choice - 1))]}"
    fi

    # Determine file path
    local file_path
    if [[ -n "${2:-}" ]]; then
        # Topic command: rex new <topic> <command>
        local topic="$name"
        local command="$2"
        mkdir -p "$target_dir/$topic"
        file_path="$target_dir/$topic/${topic}-${command}.sh"
    else
        # Standalone: rex new <command>
        file_path="$target_dir/${name}.sh"
    fi

    # Check for conflicts
    if [[ -e "$file_path" ]]; then
        echo "Error: already exists: $file_path"
        exit 1
    fi

    # Scaffold the script
    cat > "$file_path" << 'TEMPLATE'
#!/bin/bash
# Description:

TEMPLATE
    chmod +x "$file_path"
    echo "Created: $file_path"

    # Open in editor
    "${EDITOR:-vi}" "$file_path"
}

# ── Edit ──────────────────────────────────────────────────────────────────────

cmd_edit() {
    local target="${1:-}"
    if [[ -z "$target" ]]; then
        echo "Usage: rex edit <command>"
        echo "       rex edit <topic> <command>"
        exit 1
    fi

    local script=""

    # Check if first arg is a topic
    local topic_match=""
    while IFS='|' read -r topic_name topic_dir; do
        if [[ "$topic_name" == "$target" ]]; then
            topic_match="$target"
            break
        fi
    done < <(discover_topics)

    if [[ -n "$topic_match" ]]; then
        local command="${2:-}"
        if [[ -z "$command" ]]; then
            echo "Usage: rex edit <topic> <command>"
            exit 1
        fi
        script=$(resolve_command "$topic_match" "$command")
        if [[ -z "$script" ]]; then
            echo "Unknown $topic_match command: $command"
            exit 1
        fi
    else
        script=$(resolve_standalone "$target")
        if [[ -z "$script" ]]; then
            echo "Unknown command: $target"
            exit 1
        fi
    fi

    "${EDITOR:-vi}" "$script"
}

# ── Execution ─────────────────────────────────────────────────────────────────

run_script() {
    local script="$1"
    shift

    # Export full invocation for child scripts
    local invocation="rex"
    for arg in "$@"; do
        invocation+=" $(printf %q "$arg")"
    done
    export REX_CMD="$invocation"

    exec "$script" "$@"
}

# ── Main ──────────────────────────────────────────────────────────────────────

main() {
    case "${1:-}" in
        "help"|"--help"|"-h"|"")
            show_help
            ;;
        "version"|"--version"|"-v")
            echo "rex v${REX_VERSION}"
            ;;
        "list")
            list_all_commands
            ;;
        "new")
            shift
            cmd_new "$@"
            ;;
        "edit")
            shift
            cmd_edit "$@"
            ;;
        "completions")
            shift
            cmd_completions "$@"
            ;;
        "--cmplt")
            shift
            _rex_completions "$@"
            ;;
        "dirs")
            shift
            cmd_dirs "$@"
            ;;
        *)
            # Check if first arg is a known topic
            local topic_match=""
            while IFS='|' read -r topic_name topic_dir; do
                if [[ "$topic_name" == "$1" ]]; then
                    topic_match="$1"
                    break
                fi
            done < <(discover_topics)

            if [[ -n "$topic_match" ]]; then
                local topic="$1"
                local command="${2:-}"

                if [[ -z "$command" || "$command" == "help" || "$command" == "--help" || "$command" == "-h" || "$command" == "list" ]]; then
                    show_topic_help "$topic"
                else
                    local script_path
                    script_path=$(resolve_command "$topic" "$command")
                    if [[ -n "$script_path" ]]; then
                        run_script "$script_path" "${@:3}"
                    else
                        echo "Unknown $topic command: $command"
                        echo ""
                        show_topic_help "$topic"
                        exit 1
                    fi
                fi
            else
                # Try standalone command
                local script_path
                script_path=$(resolve_standalone "$1")
                if [[ -n "$script_path" ]]; then
                    run_script "$script_path" "${@:2}"
                else
                    echo "Unknown topic or command: $1"
                    echo ""
                    show_help
                    exit 1
                fi
            fi
            ;;
    esac
}

main "$@"
